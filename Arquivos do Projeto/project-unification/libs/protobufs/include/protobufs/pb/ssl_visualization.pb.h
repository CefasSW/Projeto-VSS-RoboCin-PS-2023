// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssl_visualization.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ssl_5fvisualization_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ssl_5fvisualization_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ssl_5fvisualization_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ssl_5fvisualization_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ssl_5fvisualization_2eproto;
namespace RoboCupSSL {
class Circle;
class CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class LineSegment;
class LineSegmentDefaultTypeInternal;
extern LineSegmentDefaultTypeInternal _LineSegment_default_instance_;
class Metadata;
class MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class RgbColor;
class RgbColorDefaultTypeInternal;
extern RgbColorDefaultTypeInternal _RgbColor_default_instance_;
class VisualizationFrame;
class VisualizationFrameDefaultTypeInternal;
extern VisualizationFrameDefaultTypeInternal _VisualizationFrame_default_instance_;
}  // namespace RoboCupSSL
PROTOBUF_NAMESPACE_OPEN
template<> ::RoboCupSSL::Circle* Arena::CreateMaybeMessage<::RoboCupSSL::Circle>(Arena*);
template<> ::RoboCupSSL::LineSegment* Arena::CreateMaybeMessage<::RoboCupSSL::LineSegment>(Arena*);
template<> ::RoboCupSSL::Metadata* Arena::CreateMaybeMessage<::RoboCupSSL::Metadata>(Arena*);
template<> ::RoboCupSSL::RgbColor* Arena::CreateMaybeMessage<::RoboCupSSL::RgbColor>(Arena*);
template<> ::RoboCupSSL::VisualizationFrame* Arena::CreateMaybeMessage<::RoboCupSSL::VisualizationFrame>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RoboCupSSL {

// ===================================================================

class RgbColor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoboCupSSL.RgbColor) */ {
 public:
  inline RgbColor() : RgbColor(nullptr) {};
  virtual ~RgbColor();

  RgbColor(const RgbColor& from);
  RgbColor(RgbColor&& from) noexcept
    : RgbColor() {
    *this = ::std::move(from);
  }

  inline RgbColor& operator=(const RgbColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline RgbColor& operator=(RgbColor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RgbColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RgbColor* internal_default_instance() {
    return reinterpret_cast<const RgbColor*>(
               &_RgbColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RgbColor& a, RgbColor& b) {
    a.Swap(&b);
  }
  inline void Swap(RgbColor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RgbColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RgbColor* New() const final {
    return CreateMaybeMessage<RgbColor>(nullptr);
  }

  RgbColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RgbColor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RgbColor& from);
  void MergeFrom(const RgbColor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RgbColor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoboCupSSL.RgbColor";
  }
  protected:
  explicit RgbColor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ssl_5fvisualization_2eproto);
    return ::descriptor_table_ssl_5fvisualization_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // uint32 r = 1;
  void clear_r();
  ::PROTOBUF_NAMESPACE_ID::uint32 r() const;
  void set_r(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_r() const;
  void _internal_set_r(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 g = 2;
  void clear_g();
  ::PROTOBUF_NAMESPACE_ID::uint32 g() const;
  void set_g(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_g() const;
  void _internal_set_g(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 b = 3;
  void clear_b();
  ::PROTOBUF_NAMESPACE_ID::uint32 b() const;
  void set_b(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_b() const;
  void _internal_set_b(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float a = 4;
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // @@protoc_insertion_point(class_scope:RoboCupSSL.RgbColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 r_;
  ::PROTOBUF_NAMESPACE_ID::uint32 g_;
  ::PROTOBUF_NAMESPACE_ID::uint32 b_;
  float a_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssl_5fvisualization_2eproto;
};
// -------------------------------------------------------------------

class Metadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoboCupSSL.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {};
  virtual ~Metadata();

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Metadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Metadata* New() const final {
    return CreateMaybeMessage<Metadata>(nullptr);
  }

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoboCupSSL.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ssl_5fvisualization_2eproto);
    return ::descriptor_table_ssl_5fvisualization_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerFieldNumber = 1,
    kColorFillFieldNumber = 4,
    kColorStrokeFieldNumber = 5,
    kVisibleByDefaultFieldNumber = 2,
    kOrderFieldNumber = 3,
  };
  // repeated string layer = 1;
  int layer_size() const;
  private:
  int _internal_layer_size() const;
  public:
  void clear_layer();
  const std::string& layer(int index) const;
  std::string* mutable_layer(int index);
  void set_layer(int index, const std::string& value);
  void set_layer(int index, std::string&& value);
  void set_layer(int index, const char* value);
  void set_layer(int index, const char* value, size_t size);
  std::string* add_layer();
  void add_layer(const std::string& value);
  void add_layer(std::string&& value);
  void add_layer(const char* value);
  void add_layer(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& layer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_layer();
  private:
  const std::string& _internal_layer(int index) const;
  std::string* _internal_add_layer();
  public:

  // .RoboCupSSL.RgbColor color_fill = 4;
  bool has_color_fill() const;
  private:
  bool _internal_has_color_fill() const;
  public:
  void clear_color_fill();
  const ::RoboCupSSL::RgbColor& color_fill() const;
  ::RoboCupSSL::RgbColor* release_color_fill();
  ::RoboCupSSL::RgbColor* mutable_color_fill();
  void set_allocated_color_fill(::RoboCupSSL::RgbColor* color_fill);
  private:
  const ::RoboCupSSL::RgbColor& _internal_color_fill() const;
  ::RoboCupSSL::RgbColor* _internal_mutable_color_fill();
  public:
  void unsafe_arena_set_allocated_color_fill(
      ::RoboCupSSL::RgbColor* color_fill);
  ::RoboCupSSL::RgbColor* unsafe_arena_release_color_fill();

  // .RoboCupSSL.RgbColor color_stroke = 5;
  bool has_color_stroke() const;
  private:
  bool _internal_has_color_stroke() const;
  public:
  void clear_color_stroke();
  const ::RoboCupSSL::RgbColor& color_stroke() const;
  ::RoboCupSSL::RgbColor* release_color_stroke();
  ::RoboCupSSL::RgbColor* mutable_color_stroke();
  void set_allocated_color_stroke(::RoboCupSSL::RgbColor* color_stroke);
  private:
  const ::RoboCupSSL::RgbColor& _internal_color_stroke() const;
  ::RoboCupSSL::RgbColor* _internal_mutable_color_stroke();
  public:
  void unsafe_arena_set_allocated_color_stroke(
      ::RoboCupSSL::RgbColor* color_stroke);
  ::RoboCupSSL::RgbColor* unsafe_arena_release_color_stroke();

  // bool visibleByDefault = 2;
  void clear_visiblebydefault();
  bool visiblebydefault() const;
  void set_visiblebydefault(bool value);
  private:
  bool _internal_visiblebydefault() const;
  void _internal_set_visiblebydefault(bool value);
  public:

  // int32 order = 3;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RoboCupSSL.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> layer_;
  ::RoboCupSSL::RgbColor* color_fill_;
  ::RoboCupSSL::RgbColor* color_stroke_;
  bool visiblebydefault_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssl_5fvisualization_2eproto;
};
// -------------------------------------------------------------------

class LineSegment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoboCupSSL.LineSegment) */ {
 public:
  inline LineSegment() : LineSegment(nullptr) {};
  virtual ~LineSegment();

  LineSegment(const LineSegment& from);
  LineSegment(LineSegment&& from) noexcept
    : LineSegment() {
    *this = ::std::move(from);
  }

  inline LineSegment& operator=(const LineSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineSegment& operator=(LineSegment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LineSegment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineSegment* internal_default_instance() {
    return reinterpret_cast<const LineSegment*>(
               &_LineSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LineSegment& a, LineSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(LineSegment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LineSegment* New() const final {
    return CreateMaybeMessage<LineSegment>(nullptr);
  }

  LineSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LineSegment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LineSegment& from);
  void MergeFrom(const LineSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineSegment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoboCupSSL.LineSegment";
  }
  protected:
  explicit LineSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ssl_5fvisualization_2eproto);
    return ::descriptor_table_ssl_5fvisualization_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kStartXFieldNumber = 2,
    kStartYFieldNumber = 3,
    kEndXFieldNumber = 4,
    kEndYFieldNumber = 5,
  };
  // .RoboCupSSL.Metadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::RoboCupSSL::Metadata& metadata() const;
  ::RoboCupSSL::Metadata* release_metadata();
  ::RoboCupSSL::Metadata* mutable_metadata();
  void set_allocated_metadata(::RoboCupSSL::Metadata* metadata);
  private:
  const ::RoboCupSSL::Metadata& _internal_metadata() const;
  ::RoboCupSSL::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::RoboCupSSL::Metadata* metadata);
  ::RoboCupSSL::Metadata* unsafe_arena_release_metadata();

  // float start_x = 2;
  void clear_start_x();
  float start_x() const;
  void set_start_x(float value);
  private:
  float _internal_start_x() const;
  void _internal_set_start_x(float value);
  public:

  // float start_y = 3;
  void clear_start_y();
  float start_y() const;
  void set_start_y(float value);
  private:
  float _internal_start_y() const;
  void _internal_set_start_y(float value);
  public:

  // float end_x = 4;
  void clear_end_x();
  float end_x() const;
  void set_end_x(float value);
  private:
  float _internal_end_x() const;
  void _internal_set_end_x(float value);
  public:

  // float end_y = 5;
  void clear_end_y();
  float end_y() const;
  void set_end_y(float value);
  private:
  float _internal_end_y() const;
  void _internal_set_end_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:RoboCupSSL.LineSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::RoboCupSSL::Metadata* metadata_;
  float start_x_;
  float start_y_;
  float end_x_;
  float end_y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssl_5fvisualization_2eproto;
};
// -------------------------------------------------------------------

class Circle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoboCupSSL.Circle) */ {
 public:
  inline Circle() : Circle(nullptr) {};
  virtual ~Circle();

  Circle(const Circle& from);
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circle& operator=(Circle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Circle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }
  inline void Swap(Circle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Circle* New() const final {
    return CreateMaybeMessage<Circle>(nullptr);
  }

  Circle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoboCupSSL.Circle";
  }
  protected:
  explicit Circle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ssl_5fvisualization_2eproto);
    return ::descriptor_table_ssl_5fvisualization_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kCenterXFieldNumber = 2,
    kCenterYFieldNumber = 3,
    kRadiusFieldNumber = 4,
  };
  // .RoboCupSSL.Metadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::RoboCupSSL::Metadata& metadata() const;
  ::RoboCupSSL::Metadata* release_metadata();
  ::RoboCupSSL::Metadata* mutable_metadata();
  void set_allocated_metadata(::RoboCupSSL::Metadata* metadata);
  private:
  const ::RoboCupSSL::Metadata& _internal_metadata() const;
  ::RoboCupSSL::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::RoboCupSSL::Metadata* metadata);
  ::RoboCupSSL::Metadata* unsafe_arena_release_metadata();

  // float center_x = 2;
  void clear_center_x();
  float center_x() const;
  void set_center_x(float value);
  private:
  float _internal_center_x() const;
  void _internal_set_center_x(float value);
  public:

  // float center_y = 3;
  void clear_center_y();
  float center_y() const;
  void set_center_y(float value);
  private:
  float _internal_center_y() const;
  void _internal_set_center_y(float value);
  public:

  // float radius = 4;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:RoboCupSSL.Circle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::RoboCupSSL::Metadata* metadata_;
  float center_x_;
  float center_y_;
  float radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssl_5fvisualization_2eproto;
};
// -------------------------------------------------------------------

class VisualizationFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoboCupSSL.VisualizationFrame) */ {
 public:
  inline VisualizationFrame() : VisualizationFrame(nullptr) {};
  virtual ~VisualizationFrame();

  VisualizationFrame(const VisualizationFrame& from);
  VisualizationFrame(VisualizationFrame&& from) noexcept
    : VisualizationFrame() {
    *this = ::std::move(from);
  }

  inline VisualizationFrame& operator=(const VisualizationFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualizationFrame& operator=(VisualizationFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VisualizationFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VisualizationFrame* internal_default_instance() {
    return reinterpret_cast<const VisualizationFrame*>(
               &_VisualizationFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VisualizationFrame& a, VisualizationFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(VisualizationFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualizationFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VisualizationFrame* New() const final {
    return CreateMaybeMessage<VisualizationFrame>(nullptr);
  }

  VisualizationFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VisualizationFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VisualizationFrame& from);
  void MergeFrom(const VisualizationFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisualizationFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoboCupSSL.VisualizationFrame";
  }
  protected:
  explicit VisualizationFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ssl_5fvisualization_2eproto);
    return ::descriptor_table_ssl_5fvisualization_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinesFieldNumber = 2,
    kCirclesFieldNumber = 3,
    kSenderIdFieldNumber = 1,
  };
  // repeated .RoboCupSSL.LineSegment lines = 2;
  int lines_size() const;
  private:
  int _internal_lines_size() const;
  public:
  void clear_lines();
  ::RoboCupSSL::LineSegment* mutable_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::LineSegment >*
      mutable_lines();
  private:
  const ::RoboCupSSL::LineSegment& _internal_lines(int index) const;
  ::RoboCupSSL::LineSegment* _internal_add_lines();
  public:
  const ::RoboCupSSL::LineSegment& lines(int index) const;
  ::RoboCupSSL::LineSegment* add_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::LineSegment >&
      lines() const;

  // repeated .RoboCupSSL.Circle circles = 3;
  int circles_size() const;
  private:
  int _internal_circles_size() const;
  public:
  void clear_circles();
  ::RoboCupSSL::Circle* mutable_circles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::Circle >*
      mutable_circles();
  private:
  const ::RoboCupSSL::Circle& _internal_circles(int index) const;
  ::RoboCupSSL::Circle* _internal_add_circles();
  public:
  const ::RoboCupSSL::Circle& circles(int index) const;
  ::RoboCupSSL::Circle* add_circles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::Circle >&
      circles() const;

  // string sender_id = 1;
  void clear_sender_id();
  const std::string& sender_id() const;
  void set_sender_id(const std::string& value);
  void set_sender_id(std::string&& value);
  void set_sender_id(const char* value);
  void set_sender_id(const char* value, size_t size);
  std::string* mutable_sender_id();
  std::string* release_sender_id();
  void set_allocated_sender_id(std::string* sender_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sender_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sender_id(
      std::string* sender_id);
  private:
  const std::string& _internal_sender_id() const;
  void _internal_set_sender_id(const std::string& value);
  std::string* _internal_mutable_sender_id();
  public:

  // @@protoc_insertion_point(class_scope:RoboCupSSL.VisualizationFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::LineSegment > lines_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::Circle > circles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssl_5fvisualization_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RgbColor

// uint32 r = 1;
inline void RgbColor::clear_r() {
  r_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RgbColor::_internal_r() const {
  return r_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RgbColor::r() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.RgbColor.r)
  return _internal_r();
}
inline void RgbColor::_internal_set_r(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  r_ = value;
}
inline void RgbColor::set_r(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.RgbColor.r)
}

// uint32 g = 2;
inline void RgbColor::clear_g() {
  g_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RgbColor::_internal_g() const {
  return g_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RgbColor::g() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.RgbColor.g)
  return _internal_g();
}
inline void RgbColor::_internal_set_g(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  g_ = value;
}
inline void RgbColor::set_g(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.RgbColor.g)
}

// uint32 b = 3;
inline void RgbColor::clear_b() {
  b_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RgbColor::_internal_b() const {
  return b_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RgbColor::b() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.RgbColor.b)
  return _internal_b();
}
inline void RgbColor::_internal_set_b(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  b_ = value;
}
inline void RgbColor::set_b(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.RgbColor.b)
}

// float a = 4;
inline void RgbColor::clear_a() {
  a_ = 0;
}
inline float RgbColor::_internal_a() const {
  return a_;
}
inline float RgbColor::a() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.RgbColor.a)
  return _internal_a();
}
inline void RgbColor::_internal_set_a(float value) {
  
  a_ = value;
}
inline void RgbColor::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.RgbColor.a)
}

// -------------------------------------------------------------------

// Metadata

// repeated string layer = 1;
inline int Metadata::_internal_layer_size() const {
  return layer_.size();
}
inline int Metadata::layer_size() const {
  return _internal_layer_size();
}
inline void Metadata::clear_layer() {
  layer_.Clear();
}
inline std::string* Metadata::add_layer() {
  // @@protoc_insertion_point(field_add_mutable:RoboCupSSL.Metadata.layer)
  return _internal_add_layer();
}
inline const std::string& Metadata::_internal_layer(int index) const {
  return layer_.Get(index);
}
inline const std::string& Metadata::layer(int index) const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Metadata.layer)
  return _internal_layer(index);
}
inline std::string* Metadata::mutable_layer(int index) {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.Metadata.layer)
  return layer_.Mutable(index);
}
inline void Metadata::set_layer(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:RoboCupSSL.Metadata.layer)
  layer_.Mutable(index)->assign(value);
}
inline void Metadata::set_layer(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:RoboCupSSL.Metadata.layer)
  layer_.Mutable(index)->assign(std::move(value));
}
inline void Metadata::set_layer(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  layer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RoboCupSSL.Metadata.layer)
}
inline void Metadata::set_layer(int index, const char* value, size_t size) {
  layer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoboCupSSL.Metadata.layer)
}
inline std::string* Metadata::_internal_add_layer() {
  return layer_.Add();
}
inline void Metadata::add_layer(const std::string& value) {
  layer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RoboCupSSL.Metadata.layer)
}
inline void Metadata::add_layer(std::string&& value) {
  layer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RoboCupSSL.Metadata.layer)
}
inline void Metadata::add_layer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  layer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RoboCupSSL.Metadata.layer)
}
inline void Metadata::add_layer(const char* value, size_t size) {
  layer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RoboCupSSL.Metadata.layer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Metadata::layer() const {
  // @@protoc_insertion_point(field_list:RoboCupSSL.Metadata.layer)
  return layer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Metadata::mutable_layer() {
  // @@protoc_insertion_point(field_mutable_list:RoboCupSSL.Metadata.layer)
  return &layer_;
}

// bool visibleByDefault = 2;
inline void Metadata::clear_visiblebydefault() {
  visiblebydefault_ = false;
}
inline bool Metadata::_internal_visiblebydefault() const {
  return visiblebydefault_;
}
inline bool Metadata::visiblebydefault() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Metadata.visibleByDefault)
  return _internal_visiblebydefault();
}
inline void Metadata::_internal_set_visiblebydefault(bool value) {
  
  visiblebydefault_ = value;
}
inline void Metadata::set_visiblebydefault(bool value) {
  _internal_set_visiblebydefault(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.Metadata.visibleByDefault)
}

// int32 order = 3;
inline void Metadata::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Metadata::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Metadata::order() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Metadata.order)
  return _internal_order();
}
inline void Metadata::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void Metadata::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.Metadata.order)
}

// .RoboCupSSL.RgbColor color_fill = 4;
inline bool Metadata::_internal_has_color_fill() const {
  return this != internal_default_instance() && color_fill_ != nullptr;
}
inline bool Metadata::has_color_fill() const {
  return _internal_has_color_fill();
}
inline void Metadata::clear_color_fill() {
  if (GetArena() == nullptr && color_fill_ != nullptr) {
    delete color_fill_;
  }
  color_fill_ = nullptr;
}
inline const ::RoboCupSSL::RgbColor& Metadata::_internal_color_fill() const {
  const ::RoboCupSSL::RgbColor* p = color_fill_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoboCupSSL::RgbColor*>(
      &::RoboCupSSL::_RgbColor_default_instance_);
}
inline const ::RoboCupSSL::RgbColor& Metadata::color_fill() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Metadata.color_fill)
  return _internal_color_fill();
}
inline void Metadata::unsafe_arena_set_allocated_color_fill(
    ::RoboCupSSL::RgbColor* color_fill) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_fill_);
  }
  color_fill_ = color_fill;
  if (color_fill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoboCupSSL.Metadata.color_fill)
}
inline ::RoboCupSSL::RgbColor* Metadata::release_color_fill() {
  auto temp = unsafe_arena_release_color_fill();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoboCupSSL::RgbColor* Metadata::unsafe_arena_release_color_fill() {
  // @@protoc_insertion_point(field_release:RoboCupSSL.Metadata.color_fill)
  
  ::RoboCupSSL::RgbColor* temp = color_fill_;
  color_fill_ = nullptr;
  return temp;
}
inline ::RoboCupSSL::RgbColor* Metadata::_internal_mutable_color_fill() {
  
  if (color_fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoboCupSSL::RgbColor>(GetArena());
    color_fill_ = p;
  }
  return color_fill_;
}
inline ::RoboCupSSL::RgbColor* Metadata::mutable_color_fill() {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.Metadata.color_fill)
  return _internal_mutable_color_fill();
}
inline void Metadata::set_allocated_color_fill(::RoboCupSSL::RgbColor* color_fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete color_fill_;
  }
  if (color_fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(color_fill);
    if (message_arena != submessage_arena) {
      color_fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color_fill, submessage_arena);
    }
    
  } else {
    
  }
  color_fill_ = color_fill;
  // @@protoc_insertion_point(field_set_allocated:RoboCupSSL.Metadata.color_fill)
}

// .RoboCupSSL.RgbColor color_stroke = 5;
inline bool Metadata::_internal_has_color_stroke() const {
  return this != internal_default_instance() && color_stroke_ != nullptr;
}
inline bool Metadata::has_color_stroke() const {
  return _internal_has_color_stroke();
}
inline void Metadata::clear_color_stroke() {
  if (GetArena() == nullptr && color_stroke_ != nullptr) {
    delete color_stroke_;
  }
  color_stroke_ = nullptr;
}
inline const ::RoboCupSSL::RgbColor& Metadata::_internal_color_stroke() const {
  const ::RoboCupSSL::RgbColor* p = color_stroke_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoboCupSSL::RgbColor*>(
      &::RoboCupSSL::_RgbColor_default_instance_);
}
inline const ::RoboCupSSL::RgbColor& Metadata::color_stroke() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Metadata.color_stroke)
  return _internal_color_stroke();
}
inline void Metadata::unsafe_arena_set_allocated_color_stroke(
    ::RoboCupSSL::RgbColor* color_stroke) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_stroke_);
  }
  color_stroke_ = color_stroke;
  if (color_stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoboCupSSL.Metadata.color_stroke)
}
inline ::RoboCupSSL::RgbColor* Metadata::release_color_stroke() {
  auto temp = unsafe_arena_release_color_stroke();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoboCupSSL::RgbColor* Metadata::unsafe_arena_release_color_stroke() {
  // @@protoc_insertion_point(field_release:RoboCupSSL.Metadata.color_stroke)
  
  ::RoboCupSSL::RgbColor* temp = color_stroke_;
  color_stroke_ = nullptr;
  return temp;
}
inline ::RoboCupSSL::RgbColor* Metadata::_internal_mutable_color_stroke() {
  
  if (color_stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoboCupSSL::RgbColor>(GetArena());
    color_stroke_ = p;
  }
  return color_stroke_;
}
inline ::RoboCupSSL::RgbColor* Metadata::mutable_color_stroke() {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.Metadata.color_stroke)
  return _internal_mutable_color_stroke();
}
inline void Metadata::set_allocated_color_stroke(::RoboCupSSL::RgbColor* color_stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete color_stroke_;
  }
  if (color_stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(color_stroke);
    if (message_arena != submessage_arena) {
      color_stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color_stroke, submessage_arena);
    }
    
  } else {
    
  }
  color_stroke_ = color_stroke;
  // @@protoc_insertion_point(field_set_allocated:RoboCupSSL.Metadata.color_stroke)
}

// -------------------------------------------------------------------

// LineSegment

// .RoboCupSSL.Metadata metadata = 1;
inline bool LineSegment::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool LineSegment::has_metadata() const {
  return _internal_has_metadata();
}
inline void LineSegment::clear_metadata() {
  if (GetArena() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::RoboCupSSL::Metadata& LineSegment::_internal_metadata() const {
  const ::RoboCupSSL::Metadata* p = metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoboCupSSL::Metadata*>(
      &::RoboCupSSL::_Metadata_default_instance_);
}
inline const ::RoboCupSSL::Metadata& LineSegment::metadata() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.LineSegment.metadata)
  return _internal_metadata();
}
inline void LineSegment::unsafe_arena_set_allocated_metadata(
    ::RoboCupSSL::Metadata* metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoboCupSSL.LineSegment.metadata)
}
inline ::RoboCupSSL::Metadata* LineSegment::release_metadata() {
  auto temp = unsafe_arena_release_metadata();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoboCupSSL::Metadata* LineSegment::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:RoboCupSSL.LineSegment.metadata)
  
  ::RoboCupSSL::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::RoboCupSSL::Metadata* LineSegment::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoboCupSSL::Metadata>(GetArena());
    metadata_ = p;
  }
  return metadata_;
}
inline ::RoboCupSSL::Metadata* LineSegment::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.LineSegment.metadata)
  return _internal_mutable_metadata();
}
inline void LineSegment::set_allocated_metadata(::RoboCupSSL::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:RoboCupSSL.LineSegment.metadata)
}

// float start_x = 2;
inline void LineSegment::clear_start_x() {
  start_x_ = 0;
}
inline float LineSegment::_internal_start_x() const {
  return start_x_;
}
inline float LineSegment::start_x() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.LineSegment.start_x)
  return _internal_start_x();
}
inline void LineSegment::_internal_set_start_x(float value) {
  
  start_x_ = value;
}
inline void LineSegment::set_start_x(float value) {
  _internal_set_start_x(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.LineSegment.start_x)
}

// float start_y = 3;
inline void LineSegment::clear_start_y() {
  start_y_ = 0;
}
inline float LineSegment::_internal_start_y() const {
  return start_y_;
}
inline float LineSegment::start_y() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.LineSegment.start_y)
  return _internal_start_y();
}
inline void LineSegment::_internal_set_start_y(float value) {
  
  start_y_ = value;
}
inline void LineSegment::set_start_y(float value) {
  _internal_set_start_y(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.LineSegment.start_y)
}

// float end_x = 4;
inline void LineSegment::clear_end_x() {
  end_x_ = 0;
}
inline float LineSegment::_internal_end_x() const {
  return end_x_;
}
inline float LineSegment::end_x() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.LineSegment.end_x)
  return _internal_end_x();
}
inline void LineSegment::_internal_set_end_x(float value) {
  
  end_x_ = value;
}
inline void LineSegment::set_end_x(float value) {
  _internal_set_end_x(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.LineSegment.end_x)
}

// float end_y = 5;
inline void LineSegment::clear_end_y() {
  end_y_ = 0;
}
inline float LineSegment::_internal_end_y() const {
  return end_y_;
}
inline float LineSegment::end_y() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.LineSegment.end_y)
  return _internal_end_y();
}
inline void LineSegment::_internal_set_end_y(float value) {
  
  end_y_ = value;
}
inline void LineSegment::set_end_y(float value) {
  _internal_set_end_y(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.LineSegment.end_y)
}

// -------------------------------------------------------------------

// Circle

// .RoboCupSSL.Metadata metadata = 1;
inline bool Circle::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Circle::has_metadata() const {
  return _internal_has_metadata();
}
inline void Circle::clear_metadata() {
  if (GetArena() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::RoboCupSSL::Metadata& Circle::_internal_metadata() const {
  const ::RoboCupSSL::Metadata* p = metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RoboCupSSL::Metadata*>(
      &::RoboCupSSL::_Metadata_default_instance_);
}
inline const ::RoboCupSSL::Metadata& Circle::metadata() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Circle.metadata)
  return _internal_metadata();
}
inline void Circle::unsafe_arena_set_allocated_metadata(
    ::RoboCupSSL::Metadata* metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoboCupSSL.Circle.metadata)
}
inline ::RoboCupSSL::Metadata* Circle::release_metadata() {
  auto temp = unsafe_arena_release_metadata();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RoboCupSSL::Metadata* Circle::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:RoboCupSSL.Circle.metadata)
  
  ::RoboCupSSL::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::RoboCupSSL::Metadata* Circle::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoboCupSSL::Metadata>(GetArena());
    metadata_ = p;
  }
  return metadata_;
}
inline ::RoboCupSSL::Metadata* Circle::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.Circle.metadata)
  return _internal_mutable_metadata();
}
inline void Circle::set_allocated_metadata(::RoboCupSSL::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:RoboCupSSL.Circle.metadata)
}

// float center_x = 2;
inline void Circle::clear_center_x() {
  center_x_ = 0;
}
inline float Circle::_internal_center_x() const {
  return center_x_;
}
inline float Circle::center_x() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Circle.center_x)
  return _internal_center_x();
}
inline void Circle::_internal_set_center_x(float value) {
  
  center_x_ = value;
}
inline void Circle::set_center_x(float value) {
  _internal_set_center_x(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.Circle.center_x)
}

// float center_y = 3;
inline void Circle::clear_center_y() {
  center_y_ = 0;
}
inline float Circle::_internal_center_y() const {
  return center_y_;
}
inline float Circle::center_y() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Circle.center_y)
  return _internal_center_y();
}
inline void Circle::_internal_set_center_y(float value) {
  
  center_y_ = value;
}
inline void Circle::set_center_y(float value) {
  _internal_set_center_y(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.Circle.center_y)
}

// float radius = 4;
inline void Circle::clear_radius() {
  radius_ = 0;
}
inline float Circle::_internal_radius() const {
  return radius_;
}
inline float Circle::radius() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.Circle.radius)
  return _internal_radius();
}
inline void Circle::_internal_set_radius(float value) {
  
  radius_ = value;
}
inline void Circle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.Circle.radius)
}

// -------------------------------------------------------------------

// VisualizationFrame

// string sender_id = 1;
inline void VisualizationFrame::clear_sender_id() {
  sender_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VisualizationFrame::sender_id() const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.VisualizationFrame.sender_id)
  return _internal_sender_id();
}
inline void VisualizationFrame::set_sender_id(const std::string& value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:RoboCupSSL.VisualizationFrame.sender_id)
}
inline std::string* VisualizationFrame::mutable_sender_id() {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.VisualizationFrame.sender_id)
  return _internal_mutable_sender_id();
}
inline const std::string& VisualizationFrame::_internal_sender_id() const {
  return sender_id_.Get();
}
inline void VisualizationFrame::_internal_set_sender_id(const std::string& value) {
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VisualizationFrame::set_sender_id(std::string&& value) {
  
  sender_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:RoboCupSSL.VisualizationFrame.sender_id)
}
inline void VisualizationFrame::set_sender_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:RoboCupSSL.VisualizationFrame.sender_id)
}
inline void VisualizationFrame::set_sender_id(const char* value,
    size_t size) {
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:RoboCupSSL.VisualizationFrame.sender_id)
}
inline std::string* VisualizationFrame::_internal_mutable_sender_id() {
  
  return sender_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VisualizationFrame::release_sender_id() {
  // @@protoc_insertion_point(field_release:RoboCupSSL.VisualizationFrame.sender_id)
  return sender_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VisualizationFrame::set_allocated_sender_id(std::string* sender_id) {
  if (sender_id != nullptr) {
    
  } else {
    
  }
  sender_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:RoboCupSSL.VisualizationFrame.sender_id)
}
inline std::string* VisualizationFrame::unsafe_arena_release_sender_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RoboCupSSL.VisualizationFrame.sender_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return sender_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VisualizationFrame::unsafe_arena_set_allocated_sender_id(
    std::string* sender_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sender_id != nullptr) {
    
  } else {
    
  }
  sender_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sender_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoboCupSSL.VisualizationFrame.sender_id)
}

// repeated .RoboCupSSL.LineSegment lines = 2;
inline int VisualizationFrame::_internal_lines_size() const {
  return lines_.size();
}
inline int VisualizationFrame::lines_size() const {
  return _internal_lines_size();
}
inline void VisualizationFrame::clear_lines() {
  lines_.Clear();
}
inline ::RoboCupSSL::LineSegment* VisualizationFrame::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.VisualizationFrame.lines)
  return lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::LineSegment >*
VisualizationFrame::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:RoboCupSSL.VisualizationFrame.lines)
  return &lines_;
}
inline const ::RoboCupSSL::LineSegment& VisualizationFrame::_internal_lines(int index) const {
  return lines_.Get(index);
}
inline const ::RoboCupSSL::LineSegment& VisualizationFrame::lines(int index) const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.VisualizationFrame.lines)
  return _internal_lines(index);
}
inline ::RoboCupSSL::LineSegment* VisualizationFrame::_internal_add_lines() {
  return lines_.Add();
}
inline ::RoboCupSSL::LineSegment* VisualizationFrame::add_lines() {
  // @@protoc_insertion_point(field_add:RoboCupSSL.VisualizationFrame.lines)
  return _internal_add_lines();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::LineSegment >&
VisualizationFrame::lines() const {
  // @@protoc_insertion_point(field_list:RoboCupSSL.VisualizationFrame.lines)
  return lines_;
}

// repeated .RoboCupSSL.Circle circles = 3;
inline int VisualizationFrame::_internal_circles_size() const {
  return circles_.size();
}
inline int VisualizationFrame::circles_size() const {
  return _internal_circles_size();
}
inline void VisualizationFrame::clear_circles() {
  circles_.Clear();
}
inline ::RoboCupSSL::Circle* VisualizationFrame::mutable_circles(int index) {
  // @@protoc_insertion_point(field_mutable:RoboCupSSL.VisualizationFrame.circles)
  return circles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::Circle >*
VisualizationFrame::mutable_circles() {
  // @@protoc_insertion_point(field_mutable_list:RoboCupSSL.VisualizationFrame.circles)
  return &circles_;
}
inline const ::RoboCupSSL::Circle& VisualizationFrame::_internal_circles(int index) const {
  return circles_.Get(index);
}
inline const ::RoboCupSSL::Circle& VisualizationFrame::circles(int index) const {
  // @@protoc_insertion_point(field_get:RoboCupSSL.VisualizationFrame.circles)
  return _internal_circles(index);
}
inline ::RoboCupSSL::Circle* VisualizationFrame::_internal_add_circles() {
  return circles_.Add();
}
inline ::RoboCupSSL::Circle* VisualizationFrame::add_circles() {
  // @@protoc_insertion_point(field_add:RoboCupSSL.VisualizationFrame.circles)
  return _internal_add_circles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoboCupSSL::Circle >&
VisualizationFrame::circles() const {
  // @@protoc_insertion_point(field_list:RoboCupSSL.VisualizationFrame.circles)
  return circles_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoboCupSSL

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ssl_5fvisualization_2eproto
